

# **Index Concurrency Control**



Redis是单线程数据库  ， 不用考虑并发的问题。。

# Concurrency Control

通常我们会从两个层面上来理解并发控制的正确性：

- Logical Correctness：（17 节）我是否能看到我应该要看到的数据？
- Physical Correctness：（本节）数据的内部表示是否安好？

# 大纲

Latch Modes

Index Crabbing/Coupling

Leaf Scans

Delayed Parent Updates





# Latch Modes

### Read Mode

- 多个线程可以同时读取相同的数据
- 针对相同的数据，当别的线程已经获得处于 read mode 的 latch，新的线程也可以继续获取 read mode 的 latch

### Write Mode

- 同一时间只有单个线程可以访问
- 针对相同的数据，如果获取前已经有别的线程获得任何 mode 的 latch，新的线程就无法获取 write mode  的 latch



### 读写锁  可以是依靠自旋锁的

读写锁是一种场景下的应用的  其实现可能有多种方法  可以自旋 也可以使用操作系统底层的 mutex 信号量实现



### **哈希表加锁**  

 比较好加锁  比如说开放地址哈希   所有的线程朝相同的移动 只访问单独的页/slot     不可能出现死锁

Resize 的时候需要加一个全局的写锁 	

### 使用局部锁   

1.按照Page 锁 划分

2. 按照Slot 划分

  分段锁     具体： 操作某个页面的时候     对页面加锁 离开后对页面解锁

使用槽slot    锁对象多  但是锁冲突的概率小了



例如Java中的ConcurentHashMap 实现

分段哈希表   哈希表分段      给一段加锁 

好处 ： 1。锁的粒度不是很细  一段一个锁 不用维护太多的锁	2. 保证一定的并发性   其他段不会锁



### 无锁插入 CAS

原子插入     compareAndSwap

哈希表也可以用     比较是否为空  如果已经为1 了 此次交换失败，自旋重试



# B+ Tree Concurrency Control

B+树合并分裂的操作需要加锁保护起来

我们希望在最大程度上允许多个线程同时读取、更新同一个 B+ Tree index，主要需要考虑两种情况：

- 多个线程同时修改同一个 node
- 一个线程正在遍历 B+ Tree 的同时，另一个线程正在 splits/merges nodes

以上说的第二种情况就很容易导致并发问题 读取到空值

解决方法



## Latch Crabbing/Coupling

Latch Crabbing 的基本思想如下：

- 获取 parent 的 latch
- 获取 child 的 latch
- 如果***安全\***，则可以释放 parent 的 latch

这里的“安全”指的是，当发生更新操作时，该节点不会发生 split 或 merge 的操作，即：

- 在插入元素时，节点未满
- 在删除元素时，节点超过半满

### Search

从 root 往下，不断地：

- 获取 child 的 read latch
- 释放 parent 的 read latch

### Insert/Delete

从 root 往下，按照需要获取 write latch，一旦获取了 child 的 write latch，检查它是否安全，如果安全，则释放之前获取的所有 write latch。

## 





































































































































































